problem_description: |
  The problem is to discover novel algorithms for 4x4 complex matrix multiplication using fewer complex multiplications than existing methods. Strassen's algorithm for real matrices uses 7 multiplications for 2x2 matrices (instead of 8). For 4x4 complex matrices, a known baseline is 49 complex multiplications (derived from applying Strassen recursively). AlphaEvolve discovered an algorithm using 48 complex multiplications.
  We are looking for a Python function that implements the core logic for such a decomposition/multiplication algorithm.

function_signature_info: |
  The target function should be named `decompose_tensor` (as specified in problem_config.yaml under function_details.name).
  It takes one argument: `tensor_input`.
  - `tensor_input`: Represents the two 4x4 complex matrices to be multiplied, or the structure that needs to be decomposed to find the multiplication algorithm. The exact representation of this input (e.g., as a specific tensor structure or two separate matrices) will need to be handled by the function. Assume complex numbers can be represented as tuples `(real, imaginary)` or Python's `complex` type.
  The function must return a tuple: `(decomposed_factors, num_complex_multiplications)`.
  - `decomposed_factors`: This should represent the algorithm itself, perhaps as a list of intermediate computations or factors, as described in the AlphaEvolve paper (e.g., U, V, W matrices for the decomposition factors M_k = <U_k, A> <V_k, B> <W_k, C_hat>).
  - `num_complex_multiplications`: An integer stating the total number of complex multiplications performed by the algorithm represented in `decomposed_factors`.

constraints_text: |
  - The solution MUST be implemented in pure Python.
  - The use of external libraries like NumPy, SciPy, TensorFlow, PyTorch, JAX, CuPy is STRICTLY DISALLOWED for the core algorithm computation. Standard Python math operations are allowed.
  - The algorithm must be for 4x4 complex matrices.
  - The primary goal is to minimize `num_complex_multiplications`.
  - The algorithm must be mathematically correct; the decomposed factors must correctly reconstruct the product of two arbitrary 4x4 complex matrices.
  - Focus on the logic of the decomposition and the count of multiplications.
  - Efficiency in terms of Python execution speed is secondary to correctness and minimizing complex multiplications, but grossly inefficient solutions should be avoided.

example_code_structure: |
  # This is just a conceptual guide, not a strict template.
  def decompose_tensor(tensor_input): 
      # tensor_input might represent two 4x4 complex matrices A and B
      # Or it might be a placeholder if the function is to *discover* the U,V,W factors.

      # Define U_k, V_k, W_k factors (these are 3-tuples of 2x2 matrices in AlphaEvolve's paper)
      # For 4x4 complex matrices, the factors would be different and likely more complex.
      # Example of a single factor computation (conceptual for one M_k):
      # U1 = [[(c1,c2), (c3,c4)], [(c5,c6), (c7,c8)]] # etc. for V1, W1
      # These U, V, W would be constants in the discovered algorithm.

      # The function should embody an algorithm. For example, if it were Strassen-like:
      # M1 = (A11 + A22) * (B11 + B22) # (This is 1 complex multiplication)
      # M2 = (A21 + A22) * B11        # (This is 1 complex multiplication)
      # ... (7 such terms for 2x2 real Strassen)
      # C11 = M1 + M4 - M5 + M7
      # ... etc.
      
      # The actual implementation will likely involve defining the specific set of
      # summations and products that constitute the new algorithm.
      # The `decomposed_factors` could be a representation of these steps or U,V,W constants.
      
      num_complex_multiplications = 0 # This MUST be accurately counted based on the implemented algorithm.
      # Increment for each complex multiplication step.
      
      # Placeholder for the actual factors/algorithm representation
      decomposed_factors = [] 

      # The function needs to return a representation of the algorithm (factors)
      # and the claimed number of complex multiplications.
      return decomposed_factors, num_complex_multiplications

# Additional context that might be useful for the LLM
meta_context: |
  - The AlphaEvolve paper (Fawzi et al., 2022, Nature) is the primary reference for this problem.
  - The goal is to find an algorithm analogous to how AlphaTensor found algorithms for real matrix multiplication.
  - The search space is vast. The LLM should try to propose novel combinations of operations.
  - The evaluation will check if the proposed `decomposed_factors` correctly compute 4x4 complex matrix multiplication and will use the returned `num_complex_multiplications` as the primary performance metric.
  - Think step-by-step to construct the sequence of operations that define the algorithm. 